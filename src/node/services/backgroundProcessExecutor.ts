/**
 * Unified executor for background bash processes.
 *
 * ALL bash commands are spawned through this executor with background-style
 * infrastructure (nohup, file output, exit code trap). This enables:
 *
 * 1. Uniform code path - one spawn mechanism for all bash commands
 * 2. Crash resilience - output always persisted to files
 * 3. Seamless fgâ†’bg transition - "background this" = "stop waiting"
 *
 * Uses runtime.exec for all operations, making the code runtime-agnostic.
 * Works identically for local and SSH runtimes.
 */

import type { Runtime, BackgroundHandle, ExecStream } from "@/node/runtime/Runtime";
import * as fs from "fs/promises";
import * as path from "path";
import { log } from "./log";
import {
  buildWrapperScript,
  buildSpawnCommand,
  parsePid,
  shellQuote,
  parseExitCode,
  buildTerminateCommand,
} from "@/node/runtime/backgroundCommands";
import type { SSHRuntime } from "@/node/runtime/SSHRuntime";
import { expandTildeForSSH, cdCommandForSSH } from "@/node/runtime/tildeExpansion";
import { execBuffered } from "@/node/utils/runtime/helpers";
import { toPosixPath } from "@/node/utils/paths";
import { NON_INTERACTIVE_ENV_VARS } from "@/common/constants/env";

const isWindows = process.platform === "win32";
const rootDir = isWindows ? "C:\\" : "/";

/**
 * Options for spawning a process
 */
export interface SpawnOptions {
  /** Working directory for command execution */
  cwd: string;
  /** Workspace ID for output directory organization */
  workspaceId: string;
  /** Process ID (e.g., "bash_1") - generated by BackgroundProcessManager */
  processId: string;
  /** Environment variables to inject */
  env?: Record<string, string>;
  /** Process niceness level (-20 to 19, lower = higher priority) */
  niceness?: number;
}

/**
 * Result of spawning a process
 */
export type SpawnResult =
  | { success: true; handle: BackgroundHandle; pid: number; outputDir: string }
  | { success: false; error: string };

/**
 * Detect if a runtime is an SSHRuntime by checking for SSH-specific methods.
 * This avoids circular imports while allowing type-safe SSH handle creation.
 */
function isSSHRuntime(runtime: Runtime): runtime is SSHRuntime {
  return "exec" in runtime && "getBgOutputDir" in runtime;
}

/**
 * Spawn a background process using runtime.exec (works for both local and SSH).
 *
 * All processes get the same infrastructure:
 * - nohup/setsid for process isolation
 * - stdout/stderr redirected to files
 * - Exit code captured via bash trap
 *
 * @param runtime Runtime to spawn on
 * @param script Script to execute
 * @param options Spawn options
 * @param bgOutputDir Base directory for output files (used for local, SSH uses its own config)
 */
export async function spawnProcess(
  runtime: Runtime,
  script: string,
  options: SpawnOptions,
  bgOutputDir: string
): Promise<SpawnResult> {
  const isSSH = isSSHRuntime(runtime);

  // For SSH, get the runtime's configured bgOutputDir (resolves tildes on remote)
  const effectiveBgOutputDir = isSSH ? await runtime.getBgOutputDir() : bgOutputDir;
  const quotePath = isSSH ? expandTildeForSSH : toPosixPath;
  const cdCommand = isSSH ? cdCommandForSSH : (p: string) => `cd ${toPosixPath(p)}`;

  log.debug(`BackgroundProcessExecutor.spawnProcess: Spawning in ${options.cwd}`);

  // Verify working directory exists
  const cwdCheck = await execBuffered(runtime, cdCommand(options.cwd), {
    cwd: rootDir,
    timeout: 10,
  });
  if (cwdCheck.exitCode !== 0) {
    return { success: false, error: `Working directory does not exist: ${options.cwd}` };
  }

  // Compute output paths
  const outputDir = `${effectiveBgOutputDir}/${options.workspaceId}/${options.processId}`;
  const stdoutPath = `${outputDir}/stdout.log`;
  const stderrPath = `${outputDir}/stderr.log`;
  const exitCodePath = `${outputDir}/exit_code`;

  // Quote paths for shell usage
  const outputDirQuoted = quotePath(outputDir);
  const stdoutPathQuoted = quotePath(stdoutPath);
  const stderrPathQuoted = quotePath(stderrPath);

  // Create output directory and empty files
  const mkdirResult = await execBuffered(
    runtime,
    `mkdir -p ${outputDirQuoted} && touch ${stdoutPathQuoted} ${stderrPathQuoted}`,
    { cwd: rootDir, timeout: 30 }
  );
  if (mkdirResult.exitCode !== 0) {
    return {
      success: false,
      error: `Failed to create output directory: ${mkdirResult.stderr}`,
    };
  }

  // Build wrapper script and spawn command
  // Use buildWrapperScript for local (handles Windows path conversion),
  // manual assembly for SSH (handles tilde expansion)
  let wrapperScript: string;
  if (isSSH) {
    const exitCodePathQuoted = quotePath(exitCodePath);
    const wrapperParts: string[] = [];
    wrapperParts.push(`trap 'echo $? > ${exitCodePathQuoted}' EXIT`);
    wrapperParts.push(cdCommand(options.cwd));
    const envVars = { ...options.env, ...NON_INTERACTIVE_ENV_VARS };
    for (const [key, value] of Object.entries(envVars)) {
      wrapperParts.push(`export ${key}=${shellQuote(value)}`);
    }
    wrapperParts.push(script);
    wrapperScript = wrapperParts.join(" && ");
  } else {
    wrapperScript = buildWrapperScript({
      exitCodePath: toPosixPath(exitCodePath),
      cwd: toPosixPath(options.cwd),
      env: { ...options.env, ...NON_INTERACTIVE_ENV_VARS },
      script,
    });
  }

  const spawnCommand = buildSpawnCommand({
    wrapperScript,
    stdoutPath,
    stderrPath,
    niceness: options.niceness,
    quotePath,
  });

  try {
    // No timeout - the spawn command backgrounds the process and returns immediately
    const result = await execBuffered(runtime, spawnCommand, {
      cwd: rootDir,
    });

    if (result.exitCode !== 0) {
      log.debug(`BackgroundProcessExecutor.spawnProcess: spawn command failed: ${result.stderr}`);
      return {
        success: false,
        error: `Failed to spawn background process: ${result.stderr}`,
      };
    }

    const pid = parsePid(result.stdout);
    if (!pid) {
      log.debug(`BackgroundProcessExecutor.spawnProcess: Invalid PID: ${result.stdout}`);
      return {
        success: false,
        error: `Failed to get valid PID from spawn: ${result.stdout}`,
      };
    }

    log.debug(`BackgroundProcessExecutor.spawnProcess: Spawned with PID ${pid}`);
    const handle = new RuntimeBackgroundHandle(runtime, pid, outputDir, quotePath);
    return { success: true, handle, pid, outputDir };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    log.debug(`BackgroundProcessExecutor.spawnProcess: Error: ${errorMessage}`);
    return {
      success: false,
      error: `Failed to spawn background process: ${errorMessage}`,
    };
  }
}

/**
 * Unified handle to a background process.
 * Uses runtime.exec for all operations, working identically for local and SSH.
 *
 * Output files (stdout.log, stderr.log, exit_code) are on the runtime's filesystem.
 * This handle provides lifecycle management via execBuffered commands.
 */
class RuntimeBackgroundHandle implements BackgroundHandle {
  private terminated = false;

  constructor(
    private readonly runtime: Runtime,
    private readonly pid: number,
    public readonly outputDir: string,
    private readonly quotePath: (p: string) => string
  ) {}

  /**
   * Get the exit code from the exit_code file.
   * Returns null if process is still running (file doesn't exist yet).
   */
  async getExitCode(): Promise<number | null> {
    try {
      const exitCodePath = this.quotePath(`${this.outputDir}/exit_code`);
      const result = await execBuffered(
        this.runtime,
        `cat ${exitCodePath} 2>/dev/null || echo ""`,
        { cwd: rootDir, timeout: 10 }
      );
      return parseExitCode(result.stdout);
    } catch (error) {
      log.debug(
        `RuntimeBackgroundHandle.getExitCode: Error: ${error instanceof Error ? error.message : String(error)}`
      );
      return null;
    }
  }

  /**
   * Terminate the process group.
   * Sends SIGTERM to process group, waits briefly, then SIGKILL if still running.
   */
  async terminate(): Promise<void> {
    if (this.terminated) return;

    try {
      const exitCodePath = `${this.outputDir}/exit_code`;
      const terminateCmd = buildTerminateCommand(this.pid, exitCodePath, this.quotePath);
      await execBuffered(this.runtime, terminateCmd, {
        cwd: rootDir,
        timeout: 15,
      });
      log.debug(`RuntimeBackgroundHandle: Terminated process group ${this.pid}`);
    } catch (error) {
      // Process may already be dead - that's fine
      log.debug(
        `RuntimeBackgroundHandle.terminate: Error: ${error instanceof Error ? error.message : String(error)}`
      );
    }

    this.terminated = true;
  }

  /**
   * Clean up resources.
   * No resources to clean - process runs independently via nohup.
   */
  async dispose(): Promise<void> {
    // No resources to clean up
  }

  /**
   * Write meta.json to the output directory.
   */
  async writeMeta(metaJson: string): Promise<void> {
    try {
      const metaPath = this.quotePath(`${this.outputDir}/meta.json`);
      await execBuffered(this.runtime, `cat > ${metaPath} << 'METAEOF'\n${metaJson}\nMETAEOF`, {
        cwd: rootDir,
        timeout: 10,
      });
    } catch (error) {
      log.debug(
        `RuntimeBackgroundHandle.writeMeta: Error: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  /**
   * Read output from a file at the given byte offset.
   * Uses dd to skip bytes and read remaining content - works on both local and SSH.
   */
  async readOutput(
    filename: "stdout.log" | "stderr.log",
    offset: number
  ): Promise<{ content: string; newOffset: number }> {
    try {
      const filePath = this.quotePath(`${this.outputDir}/${filename}`);
      // Use dd to skip bytes and cat the rest. dd with bs=1 skip=N reads from byte N.
      // We get file size first to know how much we read.
      const sizeResult = await execBuffered(
        this.runtime,
        `stat -c%s ${filePath} 2>/dev/null || echo 0`,
        { cwd: rootDir, timeout: 10 }
      );
      const fileSize = parseInt(sizeResult.stdout.trim(), 10) || 0;

      if (offset >= fileSize) {
        return { content: "", newOffset: offset };
      }

      // Read from offset to end of file
      const bytesToRead = fileSize - offset;
      const readResult = await execBuffered(
        this.runtime,
        `dd if=${filePath} bs=1 skip=${offset} count=${bytesToRead} 2>/dev/null`,
        { cwd: rootDir, timeout: 30 }
      );

      return {
        content: readResult.stdout,
        newOffset: offset + readResult.stdout.length,
      };
    } catch (error) {
      log.debug(
        `RuntimeBackgroundHandle.readOutput: Error: ${error instanceof Error ? error.message : String(error)}`
      );
      return { content: "", newOffset: offset };
    }
  }
}

/**
 * Options for migrating a foreground process to background
 */
export interface MigrateOptions {
  /** Working directory (for display in meta.json) */
  cwd: string;
  /** Workspace ID */
  workspaceId: string;
  /** Process ID (e.g., "bash_1") - generated by BackgroundProcessManager */
  processId: string;
  /** Original script being executed */
  script: string;
  /** Output already captured while running in foreground */
  existingOutput: string[];
  /** Human-readable name for the process */
  displayName?: string;
}

/**
 * Result of migrating a foreground process
 */
export type MigrateResult =
  | { success: true; handle: BackgroundHandle; outputDir: string }
  | { success: false; error: string };

/**
 * Migrate a foreground process to background tracking.
 *
 * This is called when user clicks "Background" on a running foreground process.
 * The process continues running, but we:
 * 1. Create output directory and write existing output
 * 2. Continue consuming streams and writing to files
 * 3. Track exit code when process completes
 * 4. Return a BackgroundHandle for the manager to track
 *
 * Note: Output files are written locally (not via runtime), so this works
 * for SSH runtime where streams are already being piped to the local machine.
 *
 * @param execStream The running process's streams
 * @param options Migration options
 * @param bgOutputDir Base directory for output files
 */
export async function migrateToBackground(
  execStream: ExecStream,
  options: MigrateOptions,
  bgOutputDir: string
): Promise<MigrateResult> {
  const outputDir = path.join(bgOutputDir, options.workspaceId, options.processId);

  try {
    // Create output directory
    await fs.mkdir(outputDir, { recursive: true });

    // Write existing output to stdout.log
    const stdoutPath = path.join(outputDir, "stdout.log");
    const stderrPath = path.join(outputDir, "stderr.log");
    await fs.writeFile(stdoutPath, options.existingOutput.join("\n") + "\n");
    await fs.writeFile(stderrPath, "");

    // Create handle that will continue writing to files
    const handle = new MigratedBackgroundHandle(execStream, outputDir, stdoutPath, stderrPath);

    // Start consuming remaining output in background
    handle.startConsuming();

    return { success: true, handle, outputDir };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    log.debug(`migrateToBackground: Error: ${errorMessage}`);
    return { success: false, error: `Failed to migrate process: ${errorMessage}` };
  }
}

/**
 * Handle for a migrated foreground process.
 *
 * Unlike RuntimeBackgroundHandle which uses runtime.exec for file operations,
 * this handle uses local filesystem directly because the streams are already
 * being piped to the local machine (even for SSH runtime).
 */
class MigratedBackgroundHandle implements BackgroundHandle {
  private exitCodeValue: number | null = null;
  private consuming = false;
  private stdoutFd: fs.FileHandle | null = null;
  private stderrFd: fs.FileHandle | null = null;

  constructor(
    private readonly execStream: ExecStream,
    public readonly outputDir: string,
    private readonly stdoutPath: string,
    private readonly stderrPath: string
  ) {}

  /**
   * Start consuming remaining output from streams and writing to files.
   * Called after handle is created to begin background file writing.
   */
  startConsuming(): void {
    if (this.consuming) return;
    this.consuming = true;

    // Consume both streams concurrently
    void this.consumeStream(this.execStream.stdout, this.stdoutPath);
    void this.consumeStream(this.execStream.stderr, this.stderrPath);

    // Track exit code
    void this.execStream.exitCode.then((code) => {
      this.exitCodeValue = code;
      // Write exit code to file
      void this.writeExitCode(code);
    });
  }

  /**
   * Consume a stream and append to file.
   */
  private async consumeStream(stream: ReadableStream<Uint8Array>, filePath: string): Promise<void> {
    try {
      const fd = await fs.open(filePath, "a");
      const reader = stream.getReader();

      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) {
            await fd.write(value);
          }
        }
      } finally {
        await fd.close();
      }
    } catch (error) {
      // Stream may have been cancelled or process killed - that's fine
      log.debug(
        `MigratedBackgroundHandle.consumeStream: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  /**
   * Write exit code to file.
   */
  private async writeExitCode(code: number): Promise<void> {
    try {
      const exitCodePath = path.join(this.outputDir, "exit_code");
      await fs.writeFile(exitCodePath, String(code));
    } catch (error) {
      log.debug(
        `MigratedBackgroundHandle.writeExitCode: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  getExitCode(): Promise<number | null> {
    return Promise.resolve(this.exitCodeValue);
  }

  async terminate(): Promise<void> {
    // ExecStream doesn't expose a kill method directly
    // Cancel the streams to stop reading (process continues but we stop tracking)
    try {
      await this.execStream.stdout.cancel();
      await this.execStream.stderr.cancel();
    } catch {
      // Streams may already be closed
    }
  }

  async dispose(): Promise<void> {
    // Close any open file handles
    await this.stdoutFd?.close().catch(() => {
      /* ignore */
    });
    await this.stderrFd?.close().catch(() => {
      /* ignore */
    });
  }

  async writeMeta(metaJson: string): Promise<void> {
    try {
      const metaPath = path.join(this.outputDir, "meta.json");
      await fs.writeFile(metaPath, metaJson);
    } catch (error) {
      log.debug(
        `MigratedBackgroundHandle.writeMeta: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  async readOutput(
    filename: "stdout.log" | "stderr.log",
    offset: number
  ): Promise<{ content: string; newOffset: number }> {
    try {
      const filePath = path.join(this.outputDir, filename);
      const stat = await fs.stat(filePath);
      const fileSize = stat.size;

      if (offset >= fileSize) {
        return { content: "", newOffset: offset };
      }

      // Read from offset to end
      const fd = await fs.open(filePath, "r");
      try {
        const buffer = Buffer.alloc(fileSize - offset);
        const { bytesRead } = await fd.read(buffer, 0, buffer.length, offset);
        return {
          content: buffer.slice(0, bytesRead).toString("utf-8"),
          newOffset: offset + bytesRead,
        };
      } finally {
        await fd.close();
      }
    } catch (error) {
      log.debug(
        `MigratedBackgroundHandle.readOutput: ${error instanceof Error ? error.message : String(error)}`
      );
      return { content: "", newOffset: offset };
    }
  }
}
