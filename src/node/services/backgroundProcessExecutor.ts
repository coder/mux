/**
 * Unified executor for background bash processes.
 *
 * ALL bash commands are spawned through this executor with background-style
 * infrastructure (nohup, file output, exit code trap). This enables:
 *
 * 1. Uniform code path - one spawn mechanism for all bash commands
 * 2. Crash resilience - output always persisted to files
 * 3. Seamless fgâ†’bg transition - "background this" = "stop waiting"
 *
 * Uses runtime.exec for all operations, making the code runtime-agnostic.
 * Works identically for local and SSH runtimes.
 */

import type { Runtime, BackgroundHandle } from "@/node/runtime/Runtime";
import { log } from "./log";
import {
  buildWrapperScript,
  buildSpawnCommand,
  parsePid,
  shellQuote,
  parseExitCode,
  buildTerminateCommand,
} from "@/node/runtime/backgroundCommands";
import type { SSHRuntime } from "@/node/runtime/SSHRuntime";
import { expandTildeForSSH, cdCommandForSSH } from "@/node/runtime/tildeExpansion";
import { execBuffered } from "@/node/utils/runtime/helpers";
import { toPosixPath } from "@/node/utils/paths";
import { NON_INTERACTIVE_ENV_VARS } from "@/common/constants/env";

const isWindows = process.platform === "win32";
const rootDir = isWindows ? "C:\\" : "/";

/**
 * Options for spawning a process
 */
export interface SpawnOptions {
  /** Working directory for command execution */
  cwd: string;
  /** Workspace ID for output directory organization */
  workspaceId: string;
  /** Process ID (e.g., "bash_1") - generated by BackgroundProcessManager */
  processId: string;
  /** Environment variables to inject */
  env?: Record<string, string>;
  /** Process niceness level (-20 to 19, lower = higher priority) */
  niceness?: number;
}

/**
 * Result of spawning a process
 */
export type SpawnResult =
  | { success: true; handle: BackgroundHandle; pid: number; outputDir: string }
  | { success: false; error: string };

/**
 * Detect if a runtime is an SSHRuntime by checking for SSH-specific methods.
 * This avoids circular imports while allowing type-safe SSH handle creation.
 */
function isSSHRuntime(runtime: Runtime): runtime is SSHRuntime {
  return "exec" in runtime && "getBgOutputDir" in runtime;
}

/**
 * Spawn a background process using runtime.exec (works for both local and SSH).
 *
 * All processes get the same infrastructure:
 * - nohup/setsid for process isolation
 * - stdout/stderr redirected to files
 * - Exit code captured via bash trap
 *
 * @param runtime Runtime to spawn on
 * @param script Script to execute
 * @param options Spawn options
 * @param bgOutputDir Base directory for output files (used for local, SSH uses its own config)
 */
export async function spawnProcess(
  runtime: Runtime,
  script: string,
  options: SpawnOptions,
  bgOutputDir: string
): Promise<SpawnResult> {
  const isSSH = isSSHRuntime(runtime);

  // For SSH, get the runtime's configured bgOutputDir (resolves tildes on remote)
  const effectiveBgOutputDir = isSSH ? await runtime.getBgOutputDir() : bgOutputDir;
  const quotePath = isSSH ? expandTildeForSSH : toPosixPath;
  const cdCommand = isSSH ? cdCommandForSSH : (p: string) => `cd ${toPosixPath(p)}`;

  log.debug(`BackgroundProcessExecutor.spawnProcess: Spawning in ${options.cwd}`);

  // Verify working directory exists
  const cwdCheck = await execBuffered(runtime, cdCommand(options.cwd), {
    cwd: rootDir,
    timeout: 10,
  });
  if (cwdCheck.exitCode !== 0) {
    return { success: false, error: `Working directory does not exist: ${options.cwd}` };
  }

  // Compute output paths
  const outputDir = `${effectiveBgOutputDir}/${options.workspaceId}/${options.processId}`;
  const stdoutPath = `${outputDir}/stdout.log`;
  const stderrPath = `${outputDir}/stderr.log`;
  const exitCodePath = `${outputDir}/exit_code`;

  // Quote paths for shell usage
  const outputDirQuoted = quotePath(outputDir);
  const stdoutPathQuoted = quotePath(stdoutPath);
  const stderrPathQuoted = quotePath(stderrPath);

  // Create output directory and empty files
  const mkdirResult = await execBuffered(
    runtime,
    `mkdir -p ${outputDirQuoted} && touch ${stdoutPathQuoted} ${stderrPathQuoted}`,
    { cwd: rootDir, timeout: 30 }
  );
  if (mkdirResult.exitCode !== 0) {
    return {
      success: false,
      error: `Failed to create output directory: ${mkdirResult.stderr}`,
    };
  }

  // Build wrapper script and spawn command
  // Use buildWrapperScript for local (handles Windows path conversion),
  // manual assembly for SSH (handles tilde expansion)
  let wrapperScript: string;
  if (isSSH) {
    const exitCodePathQuoted = quotePath(exitCodePath);
    const wrapperParts: string[] = [];
    wrapperParts.push(`trap 'echo $? > ${exitCodePathQuoted}' EXIT`);
    wrapperParts.push(cdCommand(options.cwd));
    const envVars = { ...options.env, ...NON_INTERACTIVE_ENV_VARS };
    for (const [key, value] of Object.entries(envVars)) {
      wrapperParts.push(`export ${key}=${shellQuote(value)}`);
    }
    wrapperParts.push(script);
    wrapperScript = wrapperParts.join(" && ");
  } else {
    wrapperScript = buildWrapperScript({
      exitCodePath: toPosixPath(exitCodePath),
      cwd: toPosixPath(options.cwd),
      env: { ...options.env, ...NON_INTERACTIVE_ENV_VARS },
      script,
    });
  }

  const spawnCommand = buildSpawnCommand({
    wrapperScript,
    stdoutPath,
    stderrPath,
    niceness: options.niceness,
    quotePath,
  });

  try {
    // No timeout - the spawn command backgrounds the process and returns immediately
    const result = await execBuffered(runtime, spawnCommand, {
      cwd: rootDir,
    });

    if (result.exitCode !== 0) {
      log.debug(`BackgroundProcessExecutor.spawnProcess: spawn command failed: ${result.stderr}`);
      return {
        success: false,
        error: `Failed to spawn background process: ${result.stderr}`,
      };
    }

    const pid = parsePid(result.stdout);
    if (!pid) {
      log.debug(`BackgroundProcessExecutor.spawnProcess: Invalid PID: ${result.stdout}`);
      return {
        success: false,
        error: `Failed to get valid PID from spawn: ${result.stdout}`,
      };
    }

    log.debug(`BackgroundProcessExecutor.spawnProcess: Spawned with PID ${pid}`);
    const handle = new RuntimeBackgroundHandle(runtime, pid, outputDir, quotePath);
    return { success: true, handle, pid, outputDir };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    log.debug(`BackgroundProcessExecutor.spawnProcess: Error: ${errorMessage}`);
    return {
      success: false,
      error: `Failed to spawn background process: ${errorMessage}`,
    };
  }
}

/**
 * Unified handle to a background process.
 * Uses runtime.exec for all operations, working identically for local and SSH.
 *
 * Output files (stdout.log, stderr.log, exit_code) are on the runtime's filesystem.
 * This handle provides lifecycle management via execBuffered commands.
 */
class RuntimeBackgroundHandle implements BackgroundHandle {
  private terminated = false;

  constructor(
    private readonly runtime: Runtime,
    private readonly pid: number,
    public readonly outputDir: string,
    private readonly quotePath: (p: string) => string
  ) {}

  /**
   * Get the exit code from the exit_code file.
   * Returns null if process is still running (file doesn't exist yet).
   */
  async getExitCode(): Promise<number | null> {
    try {
      const exitCodePath = this.quotePath(`${this.outputDir}/exit_code`);
      const result = await execBuffered(
        this.runtime,
        `cat ${exitCodePath} 2>/dev/null || echo ""`,
        { cwd: rootDir, timeout: 10 }
      );
      return parseExitCode(result.stdout);
    } catch (error) {
      log.debug(
        `RuntimeBackgroundHandle.getExitCode: Error: ${error instanceof Error ? error.message : String(error)}`
      );
      return null;
    }
  }

  /**
   * Terminate the process group.
   * Sends SIGTERM to process group, waits briefly, then SIGKILL if still running.
   */
  async terminate(): Promise<void> {
    if (this.terminated) return;

    try {
      const exitCodePath = `${this.outputDir}/exit_code`;
      const terminateCmd = buildTerminateCommand(this.pid, exitCodePath, this.quotePath);
      await execBuffered(this.runtime, terminateCmd, {
        cwd: rootDir,
        timeout: 15,
      });
      log.debug(`RuntimeBackgroundHandle: Terminated process group ${this.pid}`);
    } catch (error) {
      // Process may already be dead - that's fine
      log.debug(
        `RuntimeBackgroundHandle.terminate: Error: ${error instanceof Error ? error.message : String(error)}`
      );
    }

    this.terminated = true;
  }

  /**
   * Clean up resources.
   * No resources to clean - process runs independently via nohup.
   */
  async dispose(): Promise<void> {
    // No resources to clean up
  }

  /**
   * Write meta.json to the output directory.
   */
  async writeMeta(metaJson: string): Promise<void> {
    try {
      const metaPath = this.quotePath(`${this.outputDir}/meta.json`);
      await execBuffered(this.runtime, `cat > ${metaPath} << 'METAEOF'\n${metaJson}\nMETAEOF`, {
        cwd: rootDir,
        timeout: 10,
      });
    } catch (error) {
      log.debug(
        `RuntimeBackgroundHandle.writeMeta: Error: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
}
