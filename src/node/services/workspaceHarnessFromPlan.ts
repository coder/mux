import assert from "@/common/utils/assert";
import type {
  HarnessChecklistItem,
  HarnessGate,
  WorkspaceHarnessConfig,
} from "@/common/types/harness";
import { z } from "zod";

export const HarnessFromPlanDraftSchema = z
  .object({
    checklist: z
      .array(
        z
          .object({
            title: z.string().min(1),
            notes: z.string().optional(),
          })
          .strict()
      )
      .optional(),
    gates: z
      .array(
        z
          .object({
            command: z.string().min(1),
            title: z.string().optional(),
            timeoutSecs: z.number().int().positive().optional(),
          })
          .strict()
      )
      .optional(),
    loop: z
      .object({
        autoCommit: z.boolean().optional(),
      })
      .strict()
      .optional(),
  })
  .strict();

export type HarnessFromPlanDraft = z.infer<typeof HarnessFromPlanDraftSchema>;

function fallbackHarnessConfig(): WorkspaceHarnessConfig {
  return {
    version: 1,
    checklist: [{ id: "item-1", title: "Implement the plan", status: "todo" }],
    gates: [],
    loop: { autoCommit: false },
  };
}

export function isSafeHarnessGateCommand(command: string): boolean {
  assert(typeof command === "string", "command must be a string");

  const trimmed = command.trim();
  if (trimmed.length === 0) {
    return false;
  }

  // Keep gate commands single-line and boring. These are executed with a shell, and this is
  // AI-generated by default, so we heavily restrict what can be persisted.
  if (/\r|\n/.test(trimmed)) {
    return false;
  }

  if (trimmed.length > 200) {
    return false;
  }

  // Disallow common shell metacharacters that enable chaining / redirection.
  if (/[;&|><`"'$]/.test(trimmed)) {
    return false;
  }

  // Allowlist simple check runners.
  if (trimmed === "make") {
    return false;
  }

  return trimmed.startsWith("make ") || trimmed.startsWith("bun ");
}

export function createWorkspaceHarnessConfigFromPlanDraft(draft: unknown): {
  config: WorkspaceHarnessConfig;
  usedFallback: boolean;
  droppedUnsafeGates: boolean;
} {
  const parsed = HarnessFromPlanDraftSchema.safeParse(draft);
  if (!parsed.success) {
    return { config: fallbackHarnessConfig(), usedFallback: true, droppedUnsafeGates: false };
  }

  const rawChecklist = parsed.data.checklist ?? [];

  const checklist: HarnessChecklistItem[] = rawChecklist
    .map((item) => ({
      title: item.title.trim(),
      notes: typeof item.notes === "string" ? item.notes.trim() : undefined,
    }))
    .filter((item) => item.title.length > 0)
    .slice(0, 20)
    .map((item, index) => ({
      id: `item-${index + 1}`,
      title: item.title,
      status: "todo" as const,
      notes: item.notes && item.notes.length > 0 ? item.notes : undefined,
    }));

  if (checklist.length === 0) {
    return { config: fallbackHarnessConfig(), usedFallback: true, droppedUnsafeGates: false };
  }

  const rawGates = parsed.data.gates ?? [];

  let droppedUnsafeGates = false;
  const gates: HarnessGate[] = [];

  for (const [index, gate] of rawGates.entries()) {
    const command = gate.command.trim();
    if (!isSafeHarnessGateCommand(command)) {
      droppedUnsafeGates = true;
      continue;
    }

    const title =
      typeof gate.title === "string" && gate.title.trim().length > 0
        ? gate.title.trim()
        : undefined;

    gates.push({
      id: `gate-${index + 1}`,
      title,
      command,
      timeoutSecs: gate.timeoutSecs,
    });
  }

  const suggestedAutoCommit = parsed.data.loop?.autoCommit;

  // Default: only auto-commit when we have at least one safe gate.
  // If the model tried to provide unsafe gates, disable auto-commit entirely.
  const autoCommit = droppedUnsafeGates
    ? false
    : typeof suggestedAutoCommit === "boolean"
      ? suggestedAutoCommit
      : gates.length > 0;

  const config: WorkspaceHarnessConfig = {
    version: 1,
    checklist,
    gates,
    loop: { autoCommit },
  };

  return { config, usedFallback: false, droppedUnsafeGates };
}
