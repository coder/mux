import assert from "@/common/utils/assert";
import type {
  HarnessChecklistItem,
  HarnessGate,
  WorkspaceHarnessConfig,
} from "@/common/types/harness";
import { z } from "zod";

export const HarnessFromPlanDraftSchema = z
  .object({
    checklist: z
      .array(
        z
          .object({
            title: z.string().min(1),
            notes: z.string().optional(),
          })
          .strict()
      )
      .optional(),
    gates: z
      .array(
        z
          .object({
            command: z.string().min(1),
            title: z.string().optional(),
            timeoutSecs: z.number().int().positive().optional(),
          })
          .strict()
      )
      .optional(),
    loop: z
      .object({
        autoCommit: z.boolean().optional(),
      })
      .strict()
      .optional(),
  })
  .strict();

export type HarnessFromPlanDraft = z.infer<typeof HarnessFromPlanDraftSchema>;

function fallbackHarnessConfig(): WorkspaceHarnessConfig {
  return {
    version: 1,
    checklist: [{ id: "item-1", title: "Implement the plan", status: "todo" }],
    gates: [],
    loop: { autoCommit: false },
  };
}

const MAX_CHECKLIST_TITLE_LENGTH = 200;

function isTriviallyBadChecklistTitle(title: string): boolean {
  assert(typeof title === "string", "title must be a string");

  const trimmed = title.trim();
  if (trimmed.length === 0) return true;

  const normalized = trimmed.toLowerCase();
  if (
    normalized === "todo" ||
    normalized === "tbd" ||
    normalized === "todo." ||
    normalized === "tbd."
  ) {
    return true;
  }

  return trimmed.length > MAX_CHECKLIST_TITLE_LENGTH;
}

export function isSafeHarnessGateCommand(command: string): boolean {
  assert(typeof command === "string", "command must be a string");

  const trimmed = command.trim();
  if (trimmed.length === 0) {
    return false;
  }

  // Keep gate commands single-line and boring. These are executed with a shell, and this is
  // AI-generated by default, so we heavily restrict what can be persisted.
  if (/\r|\n/.test(trimmed)) {
    return false;
  }

  if (trimmed.length > 200) {
    return false;
  }

  // Disallow common shell metacharacters that enable chaining / redirection.
  if (/[;&|><`"'$]/.test(trimmed)) {
    return false;
  }

  // Allowlist simple check runners.
  if (trimmed === "make") {
    return false;
  }

  return trimmed.startsWith("make ") || trimmed.startsWith("bun ");
}

export function createWorkspaceHarnessConfigFromPlanDraft(draft: unknown): {
  config: WorkspaceHarnessConfig;
  usedFallback: boolean;
  droppedUnsafeGates: boolean;
} {
  const parsed = HarnessFromPlanDraftSchema.safeParse(draft);
  if (!parsed.success) {
    return { config: fallbackHarnessConfig(), usedFallback: true, droppedUnsafeGates: false };
  }

  const rawChecklist = parsed.data.checklist ?? [];

  const checklist: HarnessChecklistItem[] = [];
  const seenTitles = new Set<string>();

  for (const item of rawChecklist) {
    const title = item.title.trim();
    if (title.length === 0) continue;
    if (isTriviallyBadChecklistTitle(title)) continue;

    const normalizedTitle = title.toLowerCase();
    if (seenTitles.has(normalizedTitle)) continue;
    seenTitles.add(normalizedTitle);

    const notes = typeof item.notes === "string" ? item.notes.trim() : undefined;

    checklist.push({
      id: `item-${checklist.length + 1}`,
      title,
      status: "todo" as const,
      notes: notes && notes.length > 0 ? notes : undefined,
    });

    if (checklist.length >= 20) break;
  }

  if (checklist.length === 0) {
    return { config: fallbackHarnessConfig(), usedFallback: true, droppedUnsafeGates: false };
  }

  const rawGates = parsed.data.gates ?? [];

  let droppedUnsafeGates = false;
  const gates: HarnessGate[] = [];

  for (const [index, gate] of rawGates.entries()) {
    const command = gate.command.trim();
    if (!isSafeHarnessGateCommand(command)) {
      droppedUnsafeGates = true;
      continue;
    }

    const title =
      typeof gate.title === "string" && gate.title.trim().length > 0
        ? gate.title.trim()
        : undefined;

    gates.push({
      id: `gate-${index + 1}`,
      title,
      command,
      timeoutSecs: gate.timeoutSecs,
    });
  }

  const suggestedAutoCommit = parsed.data.loop?.autoCommit;

  // Default: only auto-commit when we have at least one safe gate.
  // If the model tried to provide unsafe gates, disable auto-commit entirely.
  const autoCommit = droppedUnsafeGates
    ? false
    : typeof suggestedAutoCommit === "boolean"
      ? suggestedAutoCommit
      : gates.length > 0;

  const config: WorkspaceHarnessConfig = {
    version: 1,
    checklist,
    gates,
    loop: { autoCommit },
  };

  return { config, usedFallback: false, droppedUnsafeGates };
}

export function extractJsonObjectFromMarkdown(
  markdown: string
): { success: true; data: unknown } | { success: false; error: string } {
  assert(typeof markdown === "string", "markdown must be a string");

  const trimmed = markdown.trim();
  if (trimmed.length === 0) {
    return { success: false, error: "Empty agent_report" };
  }

  const fencedMatch = /```json\s*([\s\S]*?)```/i.exec(trimmed);
  const candidate = (fencedMatch ? fencedMatch[1] : trimmed).trim();

  const tryParse = (text: string): { ok: true; value: unknown } | { ok: false; error: string } => {
    try {
      return { ok: true, value: JSON.parse(text) };
    } catch (error) {
      return { ok: false, error: error instanceof Error ? error.message : String(error) };
    }
  };

  let parsed = tryParse(candidate);
  if (!parsed.ok && !fencedMatch) {
    const start = trimmed.indexOf("{");
    const end = trimmed.lastIndexOf("}");
    if (start !== -1 && end !== -1 && end > start) {
      parsed = tryParse(trimmed.slice(start, end + 1));
    }
  }

  if (!parsed.ok) {
    return { success: false, error: `Failed to parse JSON: ${parsed.error}` };
  }

  if (typeof parsed.value !== "object" || parsed.value === null || Array.isArray(parsed.value)) {
    return { success: false, error: "Expected a JSON object" };
  }

  return { success: true, data: parsed.value };
}
