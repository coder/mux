import { parseCommand } from "./parser";

describe("/fork command", () => {
  it("should parse /fork without arguments to fork with autogenerated name", () => {
    const result = parseCommand("/fork");
    expect(result).toEqual({
      type: "fork",
      newName: undefined,
    });
  });

  it("should parse /fork with new name", () => {
    const result = parseCommand("/fork new-workspace");
    expect(result).toEqual({
      type: "fork",
      newName: "new-workspace",
    });
  });

  it("should ignore extra content after name (legacy continue message)", () => {
    const result = parseCommand("/fork new-workspace Continue with feature X");
    expect(result).toEqual({
      type: "fork",
      newName: "new-workspace",
    });
  });

  it("should ignore multiline content after name (legacy continue message)", () => {
    const result = parseCommand("/fork new-workspace\nContinue with feature X");
    expect(result).toEqual({
      type: "fork",
      newName: "new-workspace",
    });
  });

  it("should handle quoted workspace names", () => {
    const result = parseCommand('/fork "my workspace"');
    expect(result).toEqual({
      type: "fork",
      newName: "my workspace",
    });
  });

  it("should ignore multiline content when no name is provided", () => {
    const result = parseCommand("/fork\nContinue with feature X");
    expect(result).toEqual({
      type: "fork",
      newName: undefined,
    });
  });
});
