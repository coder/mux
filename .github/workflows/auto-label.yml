# =============================================================================
# Auto-Label Workflow
# =============================================================================
#
# This workflow automatically applies labels to new issues and pull requests
# using an AI agent (mux run). The agent analyzes the content and selects
# appropriate labels from the repository's existing label set.
#
# SETUP REQUIREMENTS:
# 1. Add ANTHROPIC_API_KEY to your repository secrets
# 2. Ensure your repo has labels defined (the agent will use existing labels)
#
# HOW IT WORKS:
# 1. Triggered when an issue or PR is opened
# 2. Fetches all available labels from the repository
# 3. Uses mux run to analyze the content and select appropriate labels
# 4. Applies the selected labels via GitHub CLI
#
# SECURITY NOTE:
# We use pull_request_target instead of pull_request so that secrets are
# available even for PRs from forks. This is safe because:
# - We only read PR metadata (title/body), not fork code
# - We don't checkout the PR head, only the base branch
# - The mux prompt only sees the title/body text, not executable code
#
# =============================================================================

name: Auto-Label Issues and PRs

# -----------------------------------------------------------------------------
# Triggers: Run on new issues and pull requests
# Note: pull_request_target runs in base repo context, enabling secrets for forks
# -----------------------------------------------------------------------------
on:
  issues:
    types: [opened]
  pull_request_target:
    types: [opened]

# -----------------------------------------------------------------------------
# Permissions: Need write access to issues/PRs for labeling
# -----------------------------------------------------------------------------
permissions:
  issues: write
  pull-requests: write
  contents: read

jobs:
  auto-label:
    runs-on: ubuntu-latest
    # Skip if the author is a bot (prevents infinite loops with other automations)
    if: github.actor != 'dependabot[bot]' && github.actor != 'github-actions[bot]'

    steps:
      # -----------------------------------------------------------------------
      # Step 1: Checkout repository
      # We need the repo context for mux to understand the project
      # -----------------------------------------------------------------------
      - name: Checkout repository
        uses: actions/checkout@v4

      # -----------------------------------------------------------------------
      # Step 2: Setup Bun runtime
      # mux is distributed as an npm package, Bun provides fast execution
      # -----------------------------------------------------------------------
      - name: Setup Bun
        uses: oven-sh/setup-bun@v2

      # -----------------------------------------------------------------------
      # Step 3: Fetch available labels
      # Get the list of labels defined in this repository so the agent
      # can choose from valid options only
      # -----------------------------------------------------------------------
      - name: Fetch repository labels
        id: labels
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get all labels as a JSON array of names
          labels=$(gh label list --json name --jq '[.[].name] | join(", ")')
          echo "available=$labels" >> "$GITHUB_OUTPUT"

      # -----------------------------------------------------------------------
      # Step 4: Prepare issue/PR content for analysis
      # Extract the title and body, handling both issues and PRs
      # -----------------------------------------------------------------------
      - name: Prepare content
        id: content
        env:
          # Use GitHub context to get issue/PR details
          ISSUE_TITLE: ${{ github.event.issue.title || github.event.pull_request.title }}
          ISSUE_BODY: ${{ github.event.issue.body || github.event.pull_request.body }}
          ISSUE_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
          IS_PR: ${{ github.event_name == 'pull_request' }}
        run: |
          # Determine content type
          if [ "$IS_PR" = "true" ]; then
            content_type="pull request"
          else
            content_type="issue"
          fi
          echo "type=$content_type" >> "$GITHUB_OUTPUT"
          echo "number=$ISSUE_NUMBER" >> "$GITHUB_OUTPUT"

          # Save title and body to files (safer than inline for special chars)
          echo "$ISSUE_TITLE" > /tmp/title.txt
          echo "$ISSUE_BODY" > /tmp/body.txt

      # -----------------------------------------------------------------------
      # Step 5: Run mux to select appropriate labels
      # The agent analyzes the content and returns a comma-separated list
      # of labels that best match the issue/PR
      # -----------------------------------------------------------------------
      - name: Select labels with mux
        id: mux
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          # Read the prepared content
          title=$(cat /tmp/title.txt)
          body=$(cat /tmp/body.txt)

          # Build the prompt for the agent
          # We ask for a simple comma-separated output for easy parsing
          prompt="You are a GitHub issue/PR labeler. Analyze this ${{ steps.content.outputs.type }} and select the most appropriate labels.

          AVAILABLE LABELS: ${{ steps.labels.outputs.available }}

          TITLE: $title

          BODY:
          $body

          INSTRUCTIONS:
          - Select 1-3 labels that best categorize this ${{ steps.content.outputs.type }}
          - Only use labels from the AVAILABLE LABELS list above
          - If no labels fit well, respond with: none
          - Respond with ONLY a comma-separated list of label names, nothing else
          - Example response: bug, documentation
          - Example response: enhancement
          - Example response: none"

          # Run mux with a timeout to prevent runaway costs
          # --quiet: Only output the final result (no streaming)
          # --timeout: Limit execution time to 2 minutes
          selected=$(bunx mux run --quiet --timeout 2m "$prompt" 2>/dev/null || echo "none")

          # Clean up the response (trim whitespace, handle newlines)
          selected=$(echo "$selected" | tr -d '\n' | xargs)

          echo "Selected labels: $selected"
          echo "labels=$selected" >> "$GITHUB_OUTPUT"

      # -----------------------------------------------------------------------
      # Step 6: Apply the selected labels
      # Use GitHub CLI to add labels to the issue/PR
      # -----------------------------------------------------------------------
      - name: Apply labels
        if: steps.mux.outputs.labels != 'none' && steps.mux.outputs.labels != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Parse the comma-separated labels and apply each one
          labels="${{ steps.mux.outputs.labels }}"

          # Determine if this is an issue or PR for the gh command
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            target="pr"
          else
            target="issue"
          fi

          # Add labels (gh handles comma-separated list)
          echo "Applying labels to $target #${{ steps.content.outputs.number }}: $labels"
          gh $target edit ${{ steps.content.outputs.number }} --add-label "$labels" || {
            echo "Warning: Some labels may not exist. Trying individually..."
            # If batch fails, try labels one at a time (handles typos gracefully)
            IFS=',' read -ra LABEL_ARRAY <<< "$labels"
            for label in "${LABEL_ARRAY[@]}"; do
              label=$(echo "$label" | xargs)  # Trim whitespace
              gh $target edit ${{ steps.content.outputs.number }} --add-label "$label" 2>/dev/null || \
                echo "Skipping invalid label: $label"
            done
          }
